/**
 * ----------------------------------
 * DOCUMENTATION GENERATED BY COPILOT
 * ----------------------------------
 * script.js - Memory Game Logic
 *
 * This file contains the main JavaScript logic for the memory game (muistipeli).
 * It handles board creation, user interactions, game state management, and UI updates.
 *
 * Main Features:
 * - Dynamically generates the game board based on user selection.
 * - Handles card flipping and matching logic.
 * - Tracks and displays the player's progress and score.
 * - Provides functions to reset or restart the game.
 *
 * Key Functions:
 * - createBoard(): Generates the game board and initializes game state.
 * - handleCardClick(event): Handles user clicks on cards, manages flipping and matching.
 * - shuffle(array): Utility function to randomize the order of cards.
 * - resetGame(): Resets the game state and UI for a new game.
 *
 * Dependencies:
 * - Assumes the presence of specific HTML elements (e.g., table cells, score display).
 * - Uses standard DOM APIs.
 *
 * Usage:
 * - Include this script in your HTML file.
 * - Ensure the DOM is fully loaded before calling createBoard().
 *
 * Author: [Your Name]
 * Date: [Date]
 */

/*TODO:
 *
 * shuffle images on board creation
 * handle flipping images on click
 * handle matching logic and disabling matched images
 * track number of guesses
 * display score and timer
 */

var board;
var clickedOnce = false;
var created = false;
var gameSizeRows, gameSizeCols;
var running = false;
var guesses;

function onClickPicture() {
  console.log("onclick toimii!");
}

function resetGame() {
  if (!running) {
    return;
  }
  created = false;
  running = false;
  guesses = 0;
  board = [];
  document.querySelectorAll("td").forEach((e) => e.remove());
}

function setGameSize() {
  let sizes = document.getElementById("sizeSelect").value.split("x");
  gameSizeRows = parseInt(sizes[0]);
  gameSizeCols = parseInt(sizes[1]);
  createBoard();
}

function startGame() {
  if (running) {
    alert("Game already running! Please reset before starting a new game.");
    return;
  }
  guesses = 0;
  running = true;
}

function assignImagesToBoard() {
  for (
    let i = 1, j = gameSizeRows * 2 + 1;
    i <= (gameSizeRows * gameSizeCols) / 2, j <= gameSizeCols * gameSizeRows;
    i++, j++
  ) {
    const img1 = document.createElement("img");
    img1.src = "../resources/img/dev_icons/dev" + i + ".jpg";
    const img2 = document.createElement("img");
    img2.src = "../resources/img/dev_icons/dev" + i + ".jpg";
    document.getElementById("pic" + i).appendChild(img1);
    document.getElementById("pic" + j).appendChild(img2);
  }
}

function createBoard() {
  if (created) {
    return;
  }
  let pictureIdAppendix = 1;
  let filenameSuffixIdx = 1;
  for (let i = 1; i <= gameSizeRows; i++) {
    let newTr = document.createElement("tr");
    newTr.setAttribute("id", "row" + i);
    for (let j = 1; j <= gameSizeCols; j++) {
      let newTd = document.createElement("td");
      newTd.setAttribute("id", "pic" + pictureIdAppendix);
      pictureIdAppendix++;
      newTd.onclick = onClickPicture;
      const img = document.createElement("img");
      img.src = "../resources/img/dev_icons/dev" + filenameSuffixIdx + ".jpg";
      newTd.appendChild(img);
      filenameSuffixIdx++;
      if (filenameSuffixIdx > (gameSizeRows * gameSizeCols) / 2) {
        filenameSuffixIdx = 1;
      }
      newTr.appendChild(newTd);
    }
    let boardContainer = document.getElementById("boardContainer");
    boardContainer.appendChild(newTr);
  }
  board = boardContainer;
  created = true;
}
